<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>全源最短路径问题-Floyd算法</title>
      <link href="/2022/07/05/Floyd/"/>
      <url>/2022/07/05/Floyd/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Floyd算法(读者可以将其读作”弗洛伊德算法”)用来解决全源最短路问题</strong></p></blockquote><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>Floyd算法基于这样一个事实:如果存在顶点K，使得以K作为中介点时顶点i和顶点j的当前最短距离缩短,则使用顶点k作为i和j的中介点,即当dis[i][j]+dis[k][j]&lt;dis[i][j]时,令dis[i][j]&#x3D;dis[i][j]+dis[k][j]。下面给出Floyd算法的伪代码。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre class="line-numbers language-none"><code class="language-none">枚举顶点k    以顶点k作为中介点,枚举所有顶点i和j        如果dis[i][j]+dis[k][j]&lt;dis[i][j]成立            赋值dis[i][j]&#x3D;dis[i][j]+dis[k][j]&#x2F;&#x2F;顶点i，j，k均属于顶点n范围内            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可以看到,Floyd算法的思维异常简洁，下面给出一种用例</strong></p><h3 id="实解"><a href="#实解" class="headerlink" title="实解"></a>实解</h3><p><strong>测试用例,以有向图为例</strong></p><pre class="line-numbers language-none"><code class="language-none">6 80 1 10 3 40 4 41 3 22 5 13 2 23 4 34 5 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define INF 10000#define MAXN 1010using namespace std;int n, m;int dis[MAXN][MAXN];void Flody() &#123;for (int k &#x3D; 0; k &lt; n; ++k) &#123;for (int i &#x3D; 0; i &lt; n; ++i) &#123;for (int j &#x3D; 0; j &lt; n; ++j) &#123;if (dis[i][k] !&#x3D; INF &amp;&amp; dis[k][j] !&#x3D; INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j]) &#123;dis[i][j] &#x3D; dis[i][k] + dis[k][j];&#125;&#125;&#125;&#125;&#125;int main() &#123;int u, v, w;fill(dis[0], dis[0] + MAXN * MAXN, INF);cin &gt;&gt; n &gt;&gt; m;for (int i &#x3D; 0; i &lt; n; ++i) &#123;dis[i][i] &#x3D; 0;&#125;for (int i &#x3D; 0; i &lt; m; ++i) &#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;dis[u][v] &#x3D; w; &#x2F;&#x2F;以有向图为例进行输入&#125;Flody();for (int i &#x3D; 0; i &lt; n; ++i) &#123;for (int j &#x3D; 0; j &lt; n; ++j) &#123;if (dis[i][j] &gt;&#x3D; INF) &#123;cout &lt;&lt; &quot;X &quot;;&#x2F;&#x2F;X表示俩点无法互相抵达&#125; else &#123;cout &lt;&lt; dis[i][j] &lt;&lt; &quot; &quot;;&#125;&#125;cout &lt;&lt; endl;&#125;return 0;&#125;            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里，给读者进行一个科普:如果一开始把图中所有点是否可达存成0-1矩阵,然后另外一个起始矩阵只有源点标一,两个矩阵乘一次后，每个点的数量就表示，从源点移动一步，到每个点的方案数,然后矩阵乘法又可以用快速幂加速,这就是我们耳熟能详的矩阵快速幂,本章节不做过多叙述，有兴趣的读者可以读阅本站&lt;矩阵快速幂&gt;章节了解相关知识或者自行查阅资料</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊单源最短路问题-Bellman-ford算法和SPFA算法</title>
      <link href="/2022/07/05/Bellman-Ford%20and%20SPFA/"/>
      <url>/2022/07/05/Bellman-Ford%20and%20SPFA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典单源最短路问题-Dijkstra算法</title>
      <link href="/2022/07/04/Dijkstra/"/>
      <url>/2022/07/04/Dijkstra/</url>
      
        <content type="html"><![CDATA[<h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><blockquote><p>使用场合:对任意给出的图G(V,E)和起点S与终点T，求解S到T点的最短路径问题</p></blockquote><h2 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a>三个步骤</h2><ol><li>设置集合S存放已被访问过的顶点，然后执行n次下面的俩个步骤(n为顶点数)</li><li>每次从集合V-S中选择与起点S的最短距离最小的一个顶点(记作u),访问并加入集合S</li><li>之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离</li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><pre class="line-numbers language-none"><code class="language-none">Dijkstra(G,d[],s)&#123;    初始化;    for(循环n次)&#123;        u &#x3D; 使d[u] 最小的还未被访问的顶点的标号;        记为u已被访问;        for(从u出发能到达的所有顶点v)&#123;            if(v未被访问&amp;&amp;以u为中介点能使s到v的最短距离d[v]更优)&#123;                更新d[v];            &#125;        &#125;    &#125;&#125;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是大多数时候题目肯定不会考的这么裸,更多的时候会出现这样一种情况，即最短路径的条数不止一条，或者给题目增加一个第二标尺，例如点权，第二边权等等，这三种情况都很容易解决,,针对这三种情况，都只要增加一个数组就可以解决，下面给出这三种解法</strong></p><ol><li>新增边权,新建一个代表第二边权的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];c[v]&#x3D;c[u]+cost[u][v];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;c[v]&#x3D;c[u]+cost[u][v];&#x2F;&#x2F;最短距离相同时更新第二边权&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>新增点权,新建一个代表新增点权的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];w[v]&#x3D;w[u]+weight[u][v];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;w[v]&#x3D;w[u]+weight[u][v];&#x2F;&#x2F;最短距离相同时更新点权&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>求最短路径条数,新建一个代表起点到某点最短路径条数的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];num[v]&#x3D;num[u];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;num[v]+&#x3D;num[u];&#x2F;&#x2F;最短距离相同时累加num&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">Emergency</a><br><img src="/./../img/Emergency.png" alt="如图"></p><h4 id="中文释义"><a href="#中文释义" class="headerlink" title="中文释义"></a>中文释义</h4><p>作为一个城市的紧急救援队长，你会得到一张你国家的特别地图。这张地图显示了几个由一些道路连接的分散城市。地图上标出了每个城市救援队的数量以及任何两个城市之间每条道路的长度。当有来自其他城市的紧急电话打给你时，你的工作是带领你的人尽快赶到那里，同时，在路上尽可能多地召集人手。</p><p>输入格式:</p><p>每个输入文件包含一个测试用例。对于每个测试用例，第一行包含4个正整数：N(≤500）-城市数量（城市编号从0到N−1） ，M-道路数量，C 1和C 2-您当前所在的城市和您必须保存的城市。下一行包含N个整数，其中第i个整数是第i个城市中救援队的数量。接下来是M条线，每条线用三个整数c1、c2和L描述一条道路，这三个整数分别是由一条道路连接的一对城市和该道路的长度。保证从C1到C2至少存在一条路径</p><p>输出格式:</p><p>对于每个测试用例，在一行中打印两个数字：C1和C2之间不同最短路径的数量，以及您可能收集的救援团队的最大数量。一行中的所有数字必须用一个空格隔开，并且在一行的末尾不允许有额外的空格。</p><p><strong>最后，上代码</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define INF 10000#define MAXN 1010using namespace std;struct node&#123;int id;int edge_power;&#125;;typedef node PLL;vector&lt;PLL&gt; vi[MAXN];&#x2F;&#x2F;点，边，起点，终点int n,m,s,k;&#x2F;&#x2F;录起点到对应点的最短距离int d[MAXN];&#x2F;&#x2F;记录各点权int point_power[MAXN];&#x2F;&#x2F;记录起点到对应点的最大点权数目int point_power_sum[MAXN];&#x2F;&#x2F;记录各点是否访问过bool vis[MAXN]&#x3D;&#123;false&#125;;&#x2F;&#x2F;记录起点到对应点的最短路径数目int num_road[MAXN];void Dijkstra(int s)&#123;fill(d,d+MAXN,INF);fill(num_road,num_road+MAXN,0);fill(point_power_sum,point_power_sum+MAXN,0);fill(vis,vis+MAXN,false);point_power_sum[s]&#x3D;point_power[s];num_road[s]&#x3D;1;d[s]&#x3D;0;for(int i&#x3D;0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;for(int j &#x3D; 0;j&lt;n;++j)&#123;if(vis[j]&#x3D;&#x3D;false&amp;&amp;d[j]&lt;MIN)&#123;u&#x3D;j;MIN&#x3D;d[j];&#125;&#125;&#x2F;&#x2F;没找到if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].id; if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].edge_power&lt;d[v])&#123;d[v]&#x3D;d[u]+vi[u][i].edge_power;num_road[v]&#x3D;num_road[u];point_power_sum[v]&#x3D;point_power[v]+point_power_sum[u];&#125;else&#123;if(d[u]+vi[u][i].edge_power&#x3D;&#x3D;d[v])&#123;if(point_power_sum[v]&lt;point_power[v]+point_power_sum[u])&#123;point_power_sum[v]&#x3D;point_power[v]+point_power_sum[u];&#125;num_road[v]+&#x3D;num_road[u];&#125;&#125;&#125;&#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;k;&#x2F;&#x2F;cout&lt;&lt;num_road[k]&lt;&lt;&quot; &quot;&lt;&lt;point_power_sum[k];for(int i &#x3D; 0;i&lt;n;++i)&#123;&#x2F;&#x2F;输入点权cin&gt;&gt;point_power[i];&#125;for(int i &#x3D; 0;i&lt;m;++i)&#123;int x,y,edge_power;cin&gt;&gt;x&gt;&gt;y&gt;&gt;edge_power;&#x2F;&#x2F;初始化点的属性PLL pi&#123;x,edge_power&#125;;PLL pt&#123;y,edge_power&#125;;&#x2F;&#x2F;设置双向可达vi[x].push_back(pt);vi[y].push_back(pi);&#125;Dijkstra(s);cout&lt;&lt;num_road[k]&lt;&lt;&quot; &quot;&lt;&lt;point_power_sum[k];return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>你以为到这里就结束了吗，细心的读者应当注意到，上面这三种情况都是以路径上的边权或点权之 “和” 为第二标尺的，事实上也可能出现一些逻辑更为复杂的计算边权或点权的方式，此时按上面的Dijkstra算法就未必能得出正确的结果(原因是不一定满足最优子结构)，或者即使能算出，其逻辑也极其复杂，很容易写错，下面给出一种更通用、又模板化的解决此类问题的方式——Dijkstra+DFS。</strong></p><p>先思考一个问题，如果我们想要获得最优路径，应该怎么做？实际上很简单，只需要设置一个pre数组，当以v为结点可优化最短距离时，设置v的前驱结点为u即可,然后不断回溯得到当前结点的前驱结点，下面一样给出通俗易懂的递归写法</p><pre class="line-numbers language-none"><code class="language-none">if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].edge_power&lt;d[v])&#123; d[v]&#x3D;d[u]+vi[u][i].edge_power;  pre[v]&#x3D;u;&#x2F;&#x2F;设置v的前驱结点为u&#125;&#x2F;&#x2F;递归回溯void DFS(int s,int t)&#123;&#x2F;&#x2F;s是起点，t是终点if(v&#x3D;&#x3D;s)&#123;cout&lt;&lt;s;return ;&#125;DFS(s,pre[t]);cout&lt;&lt;t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事实上，可以采取先找出所有最短路径的，后找出第二标尺最优的方法，下面给出步骤</strong><br><strong>1. 设置一个vector&lt; int&gt; pre[MAXN];记录每一个结点的所有前驱结点</strong><br><strong>2. 考虑更新d[v]过程中pre数组的变化，下面直接给出代码</strong></p><pre class="line-numbers language-none"><code class="language-none">if(d[u]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[u]+G[u][v];pre[v].clean();&#x2F;&#x2F;找到一条新路径，清除原先所有前驱结点pre[v].push_back(u);&#125;else&#123;if(d[u]+G[u][v]&#x3D;d[v])&#123;pre[v].push_back(u);&#x2F;&#x2F;找到一条相同距离的路径，直接添加即可&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以下给出模板代码，特别注意:下面的代码可以全部不修改直接默写上去(当然能理解最好)</strong></p><pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; pre[MAXN];void Dijkstra(int s)&#123;for(int i&#x3D;0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;&#x2F;&#x2F;找到最小的d[u]for(int j &#x3D; 0;j&lt;n;++j)&#123;if(vis[j]&#x3D;&#x3D;false&amp;&amp;d[j]&lt;MIN)&#123;u&#x3D;j;MIN&#x3D;d[j];&#125;&#125;&#x2F;&#x2F;没找到if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].id; if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+G[u][v]&lt;INF)&#123;d[v]&#x3D;d[u]+G[u][v];pre[v].clear();pre[v].push_back(u);&#125;else&#123;if(d[u]+vi[u][i].edge_power&#x3D;&#x3D;d[v])&#123;pre[v].push_back(u);&#125;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>已经求出所有最短路径了，那么怎么筛选出第二标尺最优的路径呢？读者应该还记得，在之前的写法中曾使用一个递归函数来寻找最短路径，此处的做法和之前相似，由于每个结点可以存在多个前驱结点，回溯的过程中就会形成一棵递归树，显然，对这棵树进行遍历时，每当到达叶子结点，就会产生一条完整的路径(想一想之前的写法是什么样的树————实际上就是一条链),因此，每得到一条完整路径，就可以对这条路径计算其第二标尺的值，如果比当前最优值更优，就更新最优值，并覆盖当前的最优路径，当所有最短路径都遍历之后，就可以得到最优第二标尺与最优最短路径。</strong></p><p><strong>首先，根据上面的分析，必须要有的是:</strong><br><strong>1. 作为全局变量的第二标尺最优值optValue</strong><br><strong>2. 记录最优路径的数组path(用vector存储)</strong><br><strong>3. 临时记录DFS遍历到叶子结点时的路径tempPath(也使用vector存储)</strong><br><strong>由此就可以给出下面的代码</strong></p><pre class="line-numbers language-none"><code class="language-none">int optvalue;&#x2F;&#x2F;记录局部第二标尺最优值vector&lt;int&gt; pre[MAXN];&#x2F;&#x2F;记录所有前驱结点vector&lt;int&gt; path,tempPath;&#x2F;&#x2F;最优路径和局部路径void DFS(int v)&#123;&#x2F;&#x2F;到达叶子结点if(v&#x3D;&#x3D;s)&#123;tempPath.push_back(v);int value;计算tempPath上的value值if(value优于optvalue)&#123;optvalue &#x3D; value;path &#x3D; tempPath;&#125;tempPath.pop_back();return ;&#125;&#x2F;&#x2F;递归式tempPath.push_back(v);for(int i &#x3D; 0;i&lt;pre[v].size();++i)&#123;DFS(pre[v][i]);&#125;tempPath.pop_back();&#x2F;&#x2F;遍历完所有前驱结点，将当前结点v清除&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读者会发现，上面的DFS代码中只有一样是要修改的(即”value优于optvalue”),这个要根据实际题目要求决定是大于还是小于，还有一点要注意，由于是递归的原因,存放在tempPath中的路径是逆序的，因此访问结点需要倒着进行才算正序.当然，如果仅是对边权或点权进行求和的话，那么正序访问也是可以的，下面给出这俩种情况的代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;边权之和int value &#x3D; 0;for(int i &#x3D; tempPath.size()-1 ; i &gt; 0 ; --i)&#123;&#x2F;&#x2F;当前结点id,下一个结点idnextint id &#x3D; tempPath[i],idnext &#x3D; tempPath[i-1];value +&#x3D; V[id][idnext];&#125;&#x2F;&#x2F;点权之和int value &#x3D; 0;for(int i &#x3D; tempPath.size()-1 ; i &gt; 0 ; --i)&#123;&#x2F;&#x2F;当前结点id,下一个结点idnextint id &#x3D; tempPath[i];value +&#x3D; w[id];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392">Travel Plan</a><br><img src="/./../img/Travel%20Plan.png" alt="如图"></p><h4 id="中文释义-1"><a href="#中文释义-1" class="headerlink" title="中文释义"></a>中文释义</h4><p>一张旅行者地图给出了公路沿线城市之间的距离，以及每条公路的成本。现在，您应该编写一个程序来帮助旅行者确定从出发城市到目的地之间的最短路径。如果这样的最短路径不是唯一的，那么您应该输出成本最小的路径，该路径保证是唯一的。</p><p>输入格式<br>每个输入文件包含一个测试用例。每种情况从一条包含4个正整数N、M、S和D的线开始，其中N(≤500）是城市的数量（因此城市的编号从0到N−1); M是公路数量；S和D分别是起点和终点城市。接下来是M行，每行以以下格式提供公路信息：<br><code>City1 City2 Distance Cost</code><br>输出格式<br>对于每个测试用例，在一行中打印从起点到目的地的最短路径上的城市，然后是路径的总距离和总成本。数字之间必须用空格隔开，并且输出端不得有额外的空格。</p><p><strong>以下给出俩种解法</strong></p><p><strong>1. Dijkstra</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define MAXN 10000#define INF 1000000000using namespace std;typedef pair&lt;int,int&gt; PLL;vector&lt;PLL&gt; vi[MAXN];int d[MAXN];int c[MAXN];int cost[MAXN][MAXN];int n,m,s,t;bool vis[MAXN]&#x3D;&#123;false&#125;;int pre[MAXN];void DFS(int v)&#123;if(v&#x3D;&#x3D;s)&#123;cout&lt;&lt;v&lt;&lt;&quot; &quot;;return ;&#125;DFS(pre[v]);cout&lt;&lt;v&lt;&lt;&quot; &quot;;&#125;void Dijkstra(int s)&#123;fill(d,d+MAXN,INF);fill(c,c+MAXN,0);d[s]&#x3D;0;for(int i &#x3D; 0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;for(int i &#x3D; 0;i&lt;n;++i)&#123;if(vis[i]&#x3D;&#x3D;false&amp;&amp;d[i]&lt;MIN)&#123;u&#x3D;i;MIN&#x3D;d[i];&#125;&#125;if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].first;if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].second&lt;d[v])&#123;d[v]&#x3D;d[u]+vi[u][i].second;c[v]&#x3D;c[u]+cost[u][v];pre[v]&#x3D;u;&#125;else&#123;&#x2F;&#x2F;距离相同时if(d[u]+vi[u][i].second&#x3D;&#x3D;d[v])&#123;if(c[u]+cost[u][v]&lt;c[v])&#123;c[v]&#x3D;c[u]+cost[u][v];pre[v]&#x3D;u;&#125;&#125;&#125;&#125;&#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;for(int i &#x3D; 0;i&lt;m;++i)&#123;int id1,id2,Distance,Cost;cin&gt;&gt;id1&gt;&gt;id2&gt;&gt;Distance&gt;&gt;Cost;PLL pi&#123;id1,Distance&#125;;PLL pt&#123;id2,Distance&#125;;cost[id1][id2]&#x3D;cost[id2][id1]&#x3D;Cost;vi[id1].push_back(pt);vi[id2].push_back(pi);&#125;Dijkstra(s);DFS(t);cout&lt;&lt;d[t]&lt;&lt;&quot; &quot;&lt;&lt;c[t];return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. Dijkstra+DFS</strong></p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/19/hello-world/"/>
      <url>/2022/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到Rhss的个人博客 这是我的第一篇文章. 点击 <a href="https://hexo.io/docs/">documentation</a> 了解更多关于搭建hexo远程博客的信息. 如果途中你遇到了困难，可以点击<a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> 寻找解决办法，或者在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>寻找答案. 如果你对博客搭建也十分感兴趣的话，我建议你参考<a href="https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.337.search-card.all.click&vd_source=91a49c1d79fec015398d4ac2868b7b17">这个视频</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p><code>$ hexo new &quot;My New Post&quot;</code> </p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p><code> $ hexo server</code> </p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p><code>$ hexo generate</code>  </p><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p><code> $ hexo deploy</code>  </p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Guide </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
