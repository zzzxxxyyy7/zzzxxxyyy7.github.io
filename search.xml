<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>经典单源最短路问题-Dijkstra算法</title>
      <link href="/2022/07/04/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/04/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><blockquote><p>使用场合:对任意给出的图G(V,E)和起点S与终点T，求解S到T点的最短路径问题</p></blockquote><h2 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a>三个步骤</h2><ol><li>设置集合S存放已被访问过的顶点，然后执行n次下面的俩个步骤(n为顶点数)</li><li>每次从集合V-S中选择与起点S的最短距离最小的一个顶点(记作u),访问并加入集合S</li><li>之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离</li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><pre class="line-numbers language-none"><code class="language-none">Dijkstra(G,d[],s)&#123;    初始化;    for(循环n次)&#123;        u &#x3D; 使d[u] 最小的还未被访问的顶点的标号;        记为u已被访问;        for(从u出发能到达的所有顶点v)&#123;            if(v未被访问&amp;&amp;以u为中介点能使s到v的最短距离d[v]更优)&#123;                更新d[v];            &#125;        &#125;    &#125;&#125;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是大多数时候题目肯定不会考的这么裸,更多的时候会出现这样一种情况，即最短路径的条数不止一条，或者给题目增加一个第二标尺，例如点权，第二边权等等，这三种情况都很容易解决,,针对这三种情况，都只要增加一个数组就可以解决，下面给出这三种解法</strong></p><ol><li>新增边权,新建一个代表第二边权的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];c[v]&#x3D;c[u]+cost[u][v];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;c[v]&#x3D;c[u]+cost[u][v];&#x2F;&#x2F;最短距离相同时更新第二边权&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>新增点权,新建一个代表新增点权的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];w[v]&#x3D;w[u]+weight[u][v];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;w[v]&#x3D;w[u]+weight[u][v];&#x2F;&#x2F;最短距离相同时更新点权&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>求最短路径条数,新建一个代表起点到某点最短路径条数的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];num[v]&#x3D;num[u];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;num[v]+&#x3D;num[u];&#x2F;&#x2F;最短距离相同时累加num&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">Emergency</a><br><img src="/./../img/Emergency.png" alt="如图"></p><h4 id="中文释义"><a href="#中文释义" class="headerlink" title="中文释义"></a>中文释义</h4><p>作为一个城市的紧急救援队长，你会得到一张你国家的特别地图。这张地图显示了几个由一些道路连接的分散城市。地图上标出了每个城市救援队的数量以及任何两个城市之间每条道路的长度。当有来自其他城市的紧急电话打给你时，你的工作是带领你的人尽快赶到那里，同时，在路上尽可能多地召集人手。</p><p>输入格式:</p><p>每个输入文件包含一个测试用例。对于每个测试用例，第一行包含4个正整数：N(≤500）-城市数量（城市编号从0到N−1） ，M-道路数量，C 1和C 2-您当前所在的城市和您必须保存的城市。下一行包含N个整数，其中第i个整数是第i个城市中救援队的数量。接下来是M条线，每条线用三个整数c1、c2和L描述一条道路，这三个整数分别是由一条道路连接的一对城市和该道路的长度。保证从C1到C2至少存在一条路径</p><p>输出格式:</p><p>对于每个测试用例，在一行中打印两个数字：C1和C2之间不同最短路径的数量，以及您可能收集的救援团队的最大数量。一行中的所有数字必须用一个空格隔开，并且在一行的末尾不允许有额外的空格。</p><h4 id="最后-上代码"><a href="#最后-上代码" class="headerlink" title="最后,上代码"></a>最后,上代码</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define INF 10000#define MAXN 1010using namespace std;struct node&#123;int id;int edge_power;&#125;;typedef node PLL;vector&lt;PLL&gt; vi[MAXN];&#x2F;&#x2F;点，边，起点，终点int n,m,s,k;&#x2F;&#x2F;录起点到对应点的最短距离int d[MAXN];&#x2F;&#x2F;记录各点权int point_power[MAXN];&#x2F;&#x2F;记录起点到对应点的最大点权数目int point_power_sum[MAXN];&#x2F;&#x2F;记录各点是否访问过bool vis[MAXN]&#x3D;&#123;false&#125;;&#x2F;&#x2F;记录起点到对应点的最短路径数目int num_road[MAXN];void Dijkstra(int s)&#123;fill(d,d+MAXN,INF);fill(num_road,num_road+MAXN,0);fill(point_power_sum,point_power_sum+MAXN,0);fill(vis,vis+MAXN,false);point_power_sum[s]&#x3D;point_power[s];num_road[s]&#x3D;1;d[s]&#x3D;0;for(int i&#x3D;0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;for(int j &#x3D; 0;j&lt;n;++j)&#123;if(vis[j]&#x3D;&#x3D;false&amp;&amp;d[j]&lt;MIN)&#123;u&#x3D;j;MIN&#x3D;d[j];&#125;&#125;&#x2F;&#x2F;没找到if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].id; if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].edge_power&lt;d[v])&#123;d[v]&#x3D;d[u]+vi[u][i].edge_power;num_road[v]&#x3D;num_road[u];point_power_sum[v]&#x3D;point_power[v]+point_power_sum[u];&#125;else&#123;if(d[u]+vi[u][i].edge_power&#x3D;&#x3D;d[v])&#123;if(point_power_sum[v]&lt;point_power[v]+point_power_sum[u])&#123;point_power_sum[v]&#x3D;point_power[v]+point_power_sum[u];&#125;num_road[v]+&#x3D;num_road[u];&#125;&#125;&#125;&#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;k;&#x2F;&#x2F;cout&lt;&lt;num_road[k]&lt;&lt;&quot; &quot;&lt;&lt;point_power_sum[k];for(int i &#x3D; 0;i&lt;n;++i)&#123;&#x2F;&#x2F;输入点权cin&gt;&gt;point_power[i];&#125;for(int i &#x3D; 0;i&lt;m;++i)&#123;int x,y,edge_power;cin&gt;&gt;x&gt;&gt;y&gt;&gt;edge_power;&#x2F;&#x2F;初始化点的属性PLL pi&#123;x,edge_power&#125;;PLL pt&#123;y,edge_power&#125;;&#x2F;&#x2F;设置双向可达vi[x].push_back(pt);vi[y].push_back(pi);&#125;Dijkstra(s);cout&lt;&lt;num_road[k]&lt;&lt;&quot; &quot;&lt;&lt;point_power_sum[k];return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>你以为到这里就结束了吗，细心的读者应当注意到，上面这三种情况都是以路径上的边权或点权之 “和” 为第二标尺的，事实上也可能出现一些逻辑更为复杂的计算边权或点权的方式，此时按上面的Dijkstra算法就未必能得出正确的结果(原因是不一定满足最优子结构)，或者即使能算出，其逻辑也极其复杂，很容易写错，下面给出一种更通用、又模板化的解决此类问题的方式——Dijkstra+DFS。</strong></p><p>先思考一个问题，如果我们想要获得最优路径，应该怎么做？实际上很简单，只需要设置一个pre数组，当以v为结点可优化最短距离时，设置v的前驱结点为u即可,然后不断回溯得到当前结点的前驱结点，下面一样给出通俗易懂的递归写法</p><pre class="line-numbers language-none"><code class="language-none">if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].edge_power&lt;d[v])&#123; d[v]&#x3D;d[u]+vi[u][i].edge_power;  pre[v]&#x3D;u;&#x2F;&#x2F;设置v的前驱结点为u&#125;&#x2F;&#x2F;递归回溯void DFS(int s,int t)&#123;&#x2F;&#x2F;s是起点，t是终点if(v&#x3D;&#x3D;s)&#123;cout&lt;&lt;s;return ;&#125;DFS(s,pre[t]);cout&lt;&lt;t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事实上，可以采取先找出所有最短路径的，后找出第二标尺最优的方法，下面给出步骤</strong><br><strong>1. 设置一个vector&lt; int&gt; pre[MAXN];记录每一个结点的所有前驱结点</strong><br><strong>2. 考虑更新d[v]过程中pre数组的变化，下面直接给出代码</strong></p><pre class="line-numbers language-none"><code class="language-none">if(d[u]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[u]+G[u][v];pre[v].clean();&#x2F;&#x2F;找到一条新路径，清除原先所有前驱结点pre[v].push_back(u);&#125;else&#123;if(d[u]+G[u][v]&#x3D;d[v])&#123;pre[v].push_back(u);&#x2F;&#x2F;找到一条相同距离的路径，直接添加即可&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以下给出模板代码，特别注意:下面的代码可以全部不修改直接默写上去(当然能理解最好)</strong></p><pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; pre[MAXN];void Dijkstra(int s)&#123;for(int i&#x3D;0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;&#x2F;&#x2F;找到最小的d[u]for(int j &#x3D; 0;j&lt;n;++j)&#123;if(vis[j]&#x3D;&#x3D;false&amp;&amp;d[j]&lt;MIN)&#123;u&#x3D;j;MIN&#x3D;d[j];&#125;&#125;&#x2F;&#x2F;没找到if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].id; if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+G[u][v]&lt;INF)&#123;d[v]&#x3D;d[u]+G[u][v];pre[v].clear();pre[v].push_back(u);&#125;else&#123;if(d[u]+vi[u][i].edge_power&#x3D;&#x3D;d[v])&#123;pre[v].push_back(u);&#125;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>已经求出所有最短路径了，那么怎么筛选出第二标尺最优的路径呢？读者应该还记得，在之前的写法中曾使用一个递归函数来寻找最短路径，此处的做法和之前相似，由于每个结点可以存在多个前驱结点，回溯的过程中就会形成一棵递归树，显然，对这棵树进行遍历时，每当到达叶子结点，就会产生一条完整的路径(想一想之前的写法是什么样的树————实际上就是一条链),因此，每得到一条完整路径，就可以对这条路径计算其第二标尺的值，如果比当前最优值更优，就更新最优值，并覆盖当前的最优路径，当所有最短路径都遍历之后，就可以得到最优第二标尺与最优最短路径。</strong></p><p><strong>首先，根据上面的分析，必须要有的是:</strong><br><strong>1. 作为全局变量的第二标尺最优值optValue</strong><br><strong>2. 记录最优路径的数组path(用vector存储)</strong><br><strong>3. 临时记录DFS遍历到叶子结点时的路径tempPath(也使用vector存储)</strong><br><strong>由此就可以给出下面的代码</strong></p><pre class="line-numbers language-none"><code class="language-none">int optvalue;vector&lt;int&gt; pre[MAXN];vector&lt;int&gt; path,tempPath;void DFS(int v)&#123;&#x2F;&#x2F;到达叶子结点if(v&#x3D;&#x3D;s)&#123;tempPath.push_back(v);int value;计算tempPath上的value值if(value优于optvalue)&#123;optvalue &#x3D; value;path &#x3D; tempPath;&#125;tempPath.pop_back();return ;&#125;&#x2F;&#x2F;递归式tempPath.push_back(v);for(int i &#x3D; 0;i&lt;pre[v].size();++i)&#123;DFS(pre[v][i]);&#125;tempPath.pop_back();&#x2F;&#x2F;遍历完所有前驱结点，将当前结点v清除&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/19/hello-world/"/>
      <url>/2022/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到Rhss的个人博客 这是我的第一篇文章. 点击 <a href="https://hexo.io/docs/">documentation</a> 了解更多关于搭建hexo远程博客的信息. 如果途中你遇到了困难，可以点击<a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> 寻找解决办法，或者在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>寻找答案.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p><code>$ hexo new &quot;My New Post&quot;</code> </p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p><code> $ hexo server</code> </p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p><code>$ hexo generate</code>  </p><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p><code> $ hexo deploy</code>  </p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
