<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>经典单源最短路问题-Dijkstra算法</title>
      <link href="/2022/07/04/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/04/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><blockquote><p>使用场合:对任意给出的图G(V,E)和起点S与终点T，求解S到T点的最短路径问题</p></blockquote><h2 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a>三个步骤</h2><ol><li>设置集合S存放已被访问过的顶点，然后执行n次下面的俩个步骤(n为顶点数)</li><li>每次从集合V-S中选择与起点S的最短距离最小的一个顶点(记作u),访问并加入集合S</li><li>之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离</li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><pre class="line-numbers language-none"><code class="language-none">Dijkstra(G,d[],s)&#123;    初始化;    for(循环n次)&#123;        u &#x3D; 使d[u] 最小的还未被访问的顶点的标号;        记为u已被访问;        for(从u出发能到达的所有顶点v)&#123;            if(v未被访问&amp;&amp;以u为中介点能使s到v的最短距离d[v]更优)&#123;                更新d[v];            &#125;        &#125;    &#125;&#125;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是大多数时候题目肯定不会考的这么裸,更多的时候会出现这样一种情况，即最短路径的条数不止一条，或者给题目增加一个第二标尺，例如点权，第二边权等等，这三种情况都很容易解决,,针对这三种情况，都只要增加一个数组就可以解决，下面给出这三种解法</strong></p><ol><li>新增边权,新建一个代表第二边权的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];c[v]&#x3D;c[u]+cost[u][v];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;c[v]&#x3D;c[u]+cost[u][v];&#x2F;&#x2F;最短距离相同时更新第二边权&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>新增点权,新建一个代表新增点权的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];w[v]&#x3D;w[u]+weight[u][v];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;w[v]&#x3D;w[u]+weight[u][v];&#x2F;&#x2F;最短距离相同时更新点权&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>求最短路径条数,新建一个代表起点到某点最短路径条数的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];num[v]&#x3D;num[u];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;num[v]+&#x3D;num[u];&#x2F;&#x2F;最短距离相同时累加num&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">Emergency</a><br><img src="/./../img/Emergency.png" alt="如图"></p><h4 id="中文释义"><a href="#中文释义" class="headerlink" title="中文释义"></a>中文释义</h4><p>作为一个城市的紧急救援队长，你会得到一张你国家的特别地图。这张地图显示了几个由一些道路连接的分散城市。地图上标出了每个城市救援队的数量以及任何两个城市之间每条道路的长度。当有来自其他城市的紧急电话打给你时，你的工作是带领你的人尽快赶到那里，同时，在路上尽可能多地召集人手。</p><p>输入格式:</p><p>每个输入文件包含一个测试用例。对于每个测试用例，第一行包含4个正整数：N(≤500）-城市数量（城市编号从0到N−1） ，M-道路数量，C 1和C 2-您当前所在的城市和您必须保存的城市。下一行包含N个整数，其中第i个整数是第i个城市中救援队的数量。接下来是M条线，每条线用三个整数c1、c2和L描述一条道路，这三个整数分别是由一条道路连接的一对城市和该道路的长度。保证从C1到C2至少存在一条路径</p><p>输出格式:</p><p>对于每个测试用例，在一行中打印两个数字：C1和C2之间不同最短路径的数量，以及您可能收集的救援团队的最大数量。一行中的所有数字必须用一个空格隔开，并且在一行的末尾不允许有额外的空格。</p><h4 id="最后-上代码"><a href="#最后-上代码" class="headerlink" title="最后,上代码"></a>最后,上代码</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define INF 10000#define MAXN 1010using namespace std;struct node&#123;int id;int edge_power;&#125;;typedef node PLL;vector&lt;PLL&gt; vi[MAXN];&#x2F;&#x2F;点，边，起点，终点int n,m,s,k;&#x2F;&#x2F;录起点到对应点的最短距离int d[MAXN];&#x2F;&#x2F;记录各点权int point_power[MAXN];&#x2F;&#x2F;记录起点到对应点的最大点权数目int point_power_sum[MAXN];&#x2F;&#x2F;记录各点是否访问过bool vis[MAXN]&#x3D;&#123;false&#125;;&#x2F;&#x2F;记录起点到对应点的最短路径数目int num_road[MAXN];void Dijkstra(int s)&#123;fill(d,d+MAXN,INF);fill(num_road,num_road+MAXN,0);fill(point_power_sum,point_power_sum+MAXN,0);fill(vis,vis+MAXN,false);point_power_sum[s]&#x3D;point_power[s];num_road[s]&#x3D;1;d[s]&#x3D;0;for(int i&#x3D;0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;for(int j &#x3D; 0;j&lt;n;++j)&#123;if(vis[j]&#x3D;&#x3D;false&amp;&amp;d[j]&lt;MIN)&#123;u&#x3D;j;MIN&#x3D;d[j];&#125;&#125;&#x2F;&#x2F;没找到if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].id; if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].edge_power&lt;d[v])&#123;d[v]&#x3D;d[u]+vi[u][i].edge_power;num_road[v]&#x3D;num_road[u];point_power_sum[v]&#x3D;point_power[v]+point_power_sum[u];&#125;else&#123;if(d[u]+vi[u][i].edge_power&#x3D;&#x3D;d[v])&#123;if(point_power_sum[v]&lt;point_power[v]+point_power_sum[u])&#123;point_power_sum[v]&#x3D;point_power[v]+point_power_sum[u];&#125;num_road[v]+&#x3D;num_road[u];&#125;&#125;&#125;&#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;k;&#x2F;&#x2F;cout&lt;&lt;num_road[k]&lt;&lt;&quot; &quot;&lt;&lt;point_power_sum[k];for(int i &#x3D; 0;i&lt;n;++i)&#123;&#x2F;&#x2F;输入点权cin&gt;&gt;point_power[i];&#125;for(int i &#x3D; 0;i&lt;m;++i)&#123;int x,y,edge_power;cin&gt;&gt;x&gt;&gt;y&gt;&gt;edge_power;&#x2F;&#x2F;初始化点的属性PLL pi&#123;x,edge_power&#125;;PLL pt&#123;y,edge_power&#125;;&#x2F;&#x2F;设置双向可达vi[x].push_back(pt);vi[y].push_back(pi);&#125;Dijkstra(s);cout&lt;&lt;num_road[k]&lt;&lt;&quot; &quot;&lt;&lt;point_power_sum[k];return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/19/hello-world/"/>
      <url>/2022/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到Rhss的个人博客 这是我的第一篇文章. 点击 <a href="https://hexo.io/docs/">documentation</a> 了解更多关于搭建hexo远程博客的信息. 如果途中你遇到了困难，可以点击<a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> 寻找解决办法，或者在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>寻找答案.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p><code>$ hexo new &quot;My New Post&quot;</code> </p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p><code> $ hexo server</code> </p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p><code>$ hexo generate</code>  </p><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p><code> $ hexo deploy</code>  </p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
