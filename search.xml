<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>R话茶谈</title>
      <link href="/2022/07/07/R%E8%AF%9D%E8%8C%B6%E8%B0%88/"/>
      <url>/2022/07/07/R%E8%AF%9D%E8%8C%B6%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p><strong>设置这个文章的目的是希望有一个地方可以分享一些我在代码学习过程中的心得体会，本来想着有QQ空间和朋友圈的存在，可能没必要开这么一个文章，后来考虑到QQ空间和朋友圈是本着社交意义而存在的，或许不太合适作为技术性的分享场所，于是，在2022-07-07我开设了这么一个章节，以后也会不定期的分享一些心得和体会</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Share </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经验分享-洛谷刷题日记</title>
      <link href="/2022/07/07/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB-%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2022/07/07/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB-%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1003">P1003 [NOIP2011 提高组] 铺地毯</a><br><strong>脑子短路了，倒着检索就行了，第一次写的时候还用了map+pair。。。。</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define INF 10005using namespace std;struct pad &#123;int x;int y;int length;int height;&#125;;int n, s1, s2;pad ipad[INF];int main() &#123;cin &gt;&gt; n;for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;cin &gt;&gt; ipad[i].x &gt;&gt; ipad[i].y &gt;&gt; ipad[i].length &gt;&gt; ipad[i].height;&#125;cin &gt;&gt; s1 &gt;&gt; s2;for (int i &#x3D; n; i &gt;&#x3D; 0; --i) &#123;if (s1 &gt;&#x3D; ipad[i].x &amp;&amp; s1 &lt;&#x3D; ipad[i].x + ipad[i].length &amp;&amp; s2 &gt;&#x3D; ipad[i].y &amp;&amp; s2 &lt;&#x3D; ipad[i].y + ipad[i].height) &#123;cout&lt;&lt;i;return 0;&#125;&#125;cout&lt;&lt;-1;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.luogu.com.cn/problem/P1328">P1328 [NOIP2014 提高组] 生活大爆炸版石头剪刀布</a><br><strong>第一遍写的时候没想到什么优化的写法，就把所有胜负情况都用map表示出来了，然后遍历求分数就可</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int count1 &#x3D; 0, count2 &#x3D; 0;int n, l1, l2;map&lt;pair&lt;int, int&gt;, int&gt; mp;int main() &#123;&#x2F;&#x2F;0是输，1是平，2是赢&#x2F;&#x2F;剪刀mp[ &#123;0, 0&#125;] &#x3D; 1;mp[ &#123;0, 1&#125;] &#x3D; 0;mp[ &#123;0, 2&#125;] &#x3D; 2;mp[ &#123;0, 3&#125;] &#x3D; 2;mp[ &#123;0, 4&#125;] &#x3D; 0;&#x2F;&#x2F;石头mp[ &#123;1, 0&#125;] &#x3D; 2;mp[ &#123;1, 1&#125;] &#x3D; 1;mp[ &#123;1, 2&#125;] &#x3D; 0;mp[ &#123;1, 3&#125;] &#x3D; 2;mp[ &#123;1, 4&#125;] &#x3D; 0;&#x2F;&#x2F;布mp[ &#123;2, 0&#125;] &#x3D; 0;mp[ &#123;2, 1&#125;] &#x3D; 2;mp[ &#123;2, 2&#125;] &#x3D; 1;mp[ &#123;2, 3&#125;] &#x3D; 0;mp[ &#123;2, 4&#125;] &#x3D; 2;&#x2F;&#x2F;蜥蜴人mp[ &#123;3, 0&#125;] &#x3D; 0;mp[ &#123;3, 1&#125;] &#x3D; 0;mp[ &#123;3, 2&#125;] &#x3D; 2;mp[ &#123;3, 3&#125;] &#x3D; 1;mp[ &#123;3, 4&#125;] &#x3D; 2;&#x2F;&#x2F;斯波克mp[ &#123;4, 0&#125;] &#x3D; 2;mp[ &#123;4, 1&#125;] &#x3D; 2;mp[ &#123;4, 2&#125;] &#x3D; 0;mp[ &#123;4, 3&#125;] &#x3D; 0;mp[ &#123;4, 4&#125;] &#x3D; 1;cin &gt;&gt; n &gt;&gt; l1 &gt;&gt; l2;int a[1000];int b[1000];for (int i &#x3D; 1; i &lt;&#x3D; l1; ++i) &#123;cin &gt;&gt; a[i];&#125;for (int i &#x3D; 1; i &lt;&#x3D; l2; ++i) &#123;cin &gt;&gt; b[i];&#125;int s&#x3D;1,d&#x3D;1;for(int i &#x3D; 1;i&lt;&#x3D;n;++i)&#123;if(mp[&#123;a[s],b[d]&#125;]&#x3D;&#x3D;1)&#123;count1+&#x3D;0;count2+&#x3D;0;&#125;else&#123;if(mp[&#123;a[s],b[d]&#125;]&#x3D;&#x3D;0)&#123;count2+&#x3D;1;&#125;else&#123;if(mp[&#123;a[s],b[d]&#125;]&#x3D;&#x3D;2)&#123;count1+&#x3D;1;&#125;&#125;&#125;if(i%l1&#x3D;&#x3D;0)&#123;s&#x3D;1;&#125;else&#123;s++;&#125;if(i%l2&#x3D;&#x3D;0)&#123;d&#x3D;1;&#125;else&#123;d++;&#125;&#125;cout&lt;&lt;count1&lt;&lt;&quot; &quot;&lt;&lt;count2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Practise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法杂谈-二分答案</title>
      <link href="/2022/07/07/%E7%AE%97%E6%B3%95%E6%9D%82%E8%B0%88-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
      <url>/2022/07/07/%E7%AE%97%E6%B3%95%E6%9D%82%E8%B0%88-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><strong>下面我用一段长话提出二分答案的概念</strong><br>在有些题目中，答案是有一个确定的范围限制的，我们就可以考虑一种另外的方法去解决——枚举答案，并去验证答案是否可行。实际上，枚举答案有时候也会超时。这就好比说你要从一本英汉词典上查一个单词，你从头到尾一页一页的翻着找，这样找可以保证一定能找到，但是最坏情况你要把整本词典都翻一遍，那就麻烦了。有什么改进的方法吗？当然有。考虑把这个词典从中间分开，看一下中间那一页的主要单词都是啥，然后去判断我要找的单词应该在左半部分还是右半部分，再去那一部分考虑怎么找就好了。同样的，在另一部分也是要进行划分并且判断的操作。这样一直进行下去，便能很快的找到答案，而且根本不需要翻过整个词典来。可以证明，如果一页一页的找，最多要找n次，但是用这个方法，最多找<strong>floor(log2n)<strong>次。我们把这个方法叫做“</strong>二分答案</strong>”。顾名思义，它用二分的方法枚举答案，并且枚举时判断这个答案是否可行。但是，二分并不是在所有情况下都是可用的，使用二分需要满足两个条件。<strong>一个是有界，一个是单调</strong>。二分答案应该是在一个单调闭区间上进行的。也就是说，二分答案最后得到的答案应该是一个确定值，而不是像搜索那样会出现多解。二分一般用来解决最优解问题。刚才我们说单调性，那么这个单调性应该体现在哪里呢？可以这样想，在一个区间上，有很多数，这些数可能是我们这些问题的解，换句话说，这里有很多不合法的解，也有很多合法的解。我们只考虑合法解，并称之为<strong>可行解</strong>。考虑所有可行解，我们肯定是要从这些可行解中找到一个最好的作为我们的答案， 这个答案我们称之为<strong>最优解</strong>。<strong>最优解一定可行，但可行解不一定最优</strong>。我们假设整个序列具有单调性，且一个数x为可行解，那么一般的，所有的x’(x’&lt;x)都是可行解。并且，如果有一个数y是非法解，那么一般的，所有的y’(y’&gt;y)都是非法解。<br><strong>二分答案主要分为俩个步骤，下面给出其伪代码</strong></p><pre class="line-numbers language-none"><code class="language-none">bool check(传入一个测试答案)&#123;    定义一个条件变量ans    循环求分割段数[随机应变]    判断是否符合要求&#125;(main函数内部):int ans &#x3D; -1;&#x2F;&#x2F;假设答案int pleft&#x3D;0,pright&#x3D;max_len;&#x2F;&#x2F;获取答案范围while(pleft &lt;&#x3D; pright)&#123;    int mid &#x3D; (pright - pleft) &#x2F; 2 + pleft;    if (check(mid)) &#123;        ans &#x3D; mid;        pleft &#x3D; mid + 1;    &#125; else &#123;        pright &#x3D; mid - 1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>因为我本人对二分答案的学习是从刷题开始，下面给出几道例题</strong><br><a href="https://www.luogu.com.cn/problem/P2440">P2440 木材加工</a><br><img src="/./../img/P2440%20%E6%9C%A8%E6%9D%90%E5%8A%A0%E5%B7%A5.png" alt="非常经典的一道二分答案题"></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define N 100005typedef long long ll;using namespace std;ll a[N];int n, m;bool check(int mid) &#123;ll ans &#x3D; 0;for (int i &#x3D; 0; i &lt; n; ++i) &#123;ans +&#x3D; a[i] &#x2F; mid;&#125;return ans &gt;&#x3D; m;&#125;int main() &#123;cin &gt;&gt; n &gt;&gt; m;int max_len &#x3D; 0;for (int i &#x3D; 0; i &lt; n; ++i) &#123;cin &gt;&gt; a[i];if (a[i] &gt; max_len) &#123;max_len &#x3D; a[i];&#125;&#125;int pleft &#x3D; 1, pright &#x3D; max_len;int ans &#x3D; 0;while (pleft &lt;&#x3D; pright) &#123;int mid &#x3D; (pright - pleft) &#x2F; 2 + pleft;if (check(mid)) &#123;ans &#x3D; mid;pleft &#x3D; mid + 1;&#125; else &#123;pright &#x3D; mid - 1;&#125;&#125;cout &lt;&lt; ans;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.luogu.com.cn/problem/P1577">P1577 切绳子</a><br><img src="/./../img/P1577%20%E5%88%87%E7%BB%B3%E5%AD%90.png" alt="如图"></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define MXN 1000000using namespace std;typedef long long ll;ll a[MXN];ll n, k;bool check(ll mid) &#123;ll ans &#x3D; 0;for (ll i &#x3D; 0; i &lt; n; ++i) &#123;ans +&#x3D; a[i] &#x2F; mid;&#125;return ans &gt;&#x3D; k;&#125;int main() &#123;cin &gt;&gt; n &gt;&gt; k;ll max_len &#x3D; 0;for (ll i &#x3D; 0; i &lt; n; ++i) &#123;double x;cin &gt;&gt; x;a[i] &#x3D; x * 100;if (a[i] &gt; max_len) &#123;max_len &#x3D; a[i];&#125;&#125;ll ans &#x3D; -1;ll pleft &#x3D; 0, pright &#x3D; max_len;while (pleft &lt;&#x3D; pright) &#123;ll mid &#x3D; (pright - pleft) &#x2F; 2 + pleft;if (check(mid)) &#123;ans &#x3D; mid;pleft &#x3D; mid + 1;&#125; else &#123;pright &#x3D; mid - 1;&#125;&#125;double res &#x3D; (double)ans;printf(&quot;%.2lf&quot;, res &#x2F; 100.0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.luogu.com.cn/problem/P2678">P2678 [NOIP2015 提高组] 跳石头</a><br><img src="/./../img/P2678%20%5BNOIP2015%20%E6%8F%90%E9%AB%98%E7%BB%84%5D%20%E8%B7%B3%E7%9F%B3%E5%A4%B4.png" alt="如图"></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define MXN 100000using namespace std;typedef long long ll;int l, n, m;ll a[MXN];bool check(int mid) &#123;int ans &#x3D; 0;int last &#x3D; 0;for (int i &#x3D; 0; i &lt; n; ++i) &#123;if(a[i]-last&lt;mid)&#123;ans++;continue;&#125;last&#x3D;a[i];&#125;return ans &lt;&#x3D; m;&#125;int main() &#123;cin &gt;&gt; l &gt;&gt; n &gt;&gt; m;for (int i &#x3D; 0; i &lt; n; ++i) &#123;cin &gt;&gt; a[i];&#125;int ans &#x3D; -1;int pleft &#x3D; 0, pright &#x3D; l;while (pleft &lt;&#x3D; pright) &#123;int mid &#x3D; pleft + (pright - pleft) &#x2F; 2;if (check(mid)) &#123;ans &#x3D; mid;pleft &#x3D; mid + 1;&#125; else &#123;pright &#x3D; mid - 1;&#125;&#125;cout &lt;&lt; ans;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法杂谈-Floyd算法</title>
      <link href="/2022/07/05/Floyd/"/>
      <url>/2022/07/05/Floyd/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Floyd算法(读者可以将其读作”弗洛伊德算法”)用来解决全源最短路问题</strong></p></blockquote><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>Floyd算法基于这样一个事实:如果存在顶点K，使得以K作为中介点时顶点i和顶点j的当前最短距离缩短,则使用顶点k作为i和j的中介点,即当dis[i][j]+dis[k][j]&lt;dis[i][j]时,令dis[i][j]&#x3D;dis[i][j]+dis[k][j]。下面给出Floyd算法的伪代码。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre class="line-numbers language-none"><code class="language-none">枚举顶点k    以顶点k作为中介点,枚举所有顶点i和j        如果dis[i][j]+dis[k][j]&lt;dis[i][j]成立            赋值dis[i][j]&#x3D;dis[i][j]+dis[k][j]&#x2F;&#x2F;顶点i，j，k均属于顶点n范围内            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可以看到,Floyd算法的思维异常简洁，下面给出一种用例</strong></p><h3 id="实解"><a href="#实解" class="headerlink" title="实解"></a>实解</h3><p><strong>测试用例,以有向图为例</strong></p><pre class="line-numbers language-none"><code class="language-none">6 80 1 10 3 40 4 41 3 22 5 13 2 23 4 34 5 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define INF 10000#define MAXN 1010using namespace std;int n, m;int dis[MAXN][MAXN];void Flody() &#123;for (int k &#x3D; 0; k &lt; n; ++k) &#123;for (int i &#x3D; 0; i &lt; n; ++i) &#123;for (int j &#x3D; 0; j &lt; n; ++j) &#123;if (dis[i][k] !&#x3D; INF &amp;&amp; dis[k][j] !&#x3D; INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j]) &#123;dis[i][j] &#x3D; dis[i][k] + dis[k][j];&#125;&#125;&#125;&#125;&#125;int main() &#123;int u, v, w;fill(dis[0], dis[0] + MAXN * MAXN, INF);cin &gt;&gt; n &gt;&gt; m;for (int i &#x3D; 0; i &lt; n; ++i) &#123;dis[i][i] &#x3D; 0;&#125;for (int i &#x3D; 0; i &lt; m; ++i) &#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;dis[u][v] &#x3D; w; &#x2F;&#x2F;以有向图为例进行输入&#125;Flody();for (int i &#x3D; 0; i &lt; n; ++i) &#123;for (int j &#x3D; 0; j &lt; n; ++j) &#123;if (dis[i][j] &gt;&#x3D; INF) &#123;cout &lt;&lt; &quot;X &quot;;&#x2F;&#x2F;X表示俩点无法互相抵达&#125; else &#123;cout &lt;&lt; dis[i][j] &lt;&lt; &quot; &quot;;&#125;&#125;cout &lt;&lt; endl;&#125;return 0;&#125;            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>期待输出</strong></p><pre class="line-numbers language-none"><code class="language-none">0 1 5 3 4 6X 0 4 2 5 5X X 0 X X 1X X 2 0 3 3X X X X 0 3X X X X X 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里，给读者进行一个科普:如果一开始把图中所有点是否可达存成0-1矩阵,然后另外一个起始矩阵只有源点标一,两个矩阵乘一次后，每个点的数量就表示，从源点移动一步，到每个点的方案数,然后矩阵乘法又可以用快速幂加速,这就是我们耳熟能详的矩阵快速幂,本章节不做过多叙述，有兴趣的读者可以读阅本站&lt;矩阵快速幂&gt;章节了解相关知识或者自行查阅资料</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法杂谈-Bellman-ford算法和SPFA算法</title>
      <link href="/2022/07/05/Bellman-Ford%20and%20SPFA/"/>
      <url>/2022/07/05/Bellman-Ford%20and%20SPFA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法杂谈-Dijkstra算法</title>
      <link href="/2022/07/04/Dijkstra/"/>
      <url>/2022/07/04/Dijkstra/</url>
      
        <content type="html"><![CDATA[<h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><blockquote><p>使用场合:对任意给出的图G(V,E)和起点S与终点T，求解S到T点的最短路径问题</p></blockquote><h2 id="三个步骤"><a href="#三个步骤" class="headerlink" title="三个步骤"></a>三个步骤</h2><ol><li>设置集合S存放已被访问过的顶点，然后执行n次下面的俩个步骤(n为顶点数)</li><li>每次从集合V-S中选择与起点S的最短距离最小的一个顶点(记作u),访问并加入集合S</li><li>之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离</li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><pre class="line-numbers language-none"><code class="language-none">Dijkstra(G,d[],s)&#123;    初始化;    for(循环n次)&#123;        u &#x3D; 使d[u] 最小的还未被访问的顶点的标号;        记为u已被访问;        for(从u出发能到达的所有顶点v)&#123;            if(v未被访问&amp;&amp;以u为中介点能使s到v的最短距离d[v]更优)&#123;                更新d[v];            &#125;        &#125;    &#125;&#125;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是大多数时候题目肯定不会考的这么裸,更多的时候会出现这样一种情况，即最短路径的条数不止一条，或者给题目增加一个第二标尺，例如点权，第二边权等等，这三种情况都很容易解决,,针对这三种情况，都只要增加一个数组就可以解决，下面给出这三种解法</strong></p><ol><li>新增边权,新建一个代表第二边权的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];c[v]&#x3D;c[u]+cost[u][v];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;c[v]&#x3D;c[u]+cost[u][v];&#x2F;&#x2F;最短距离相同时更新第二边权&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>新增点权,新建一个代表新增点权的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];w[v]&#x3D;w[u]+weight[u][v];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;w[v]&#x3D;w[u]+weight[u][v];&#x2F;&#x2F;最短距离相同时更新点权&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>求最短路径条数,新建一个代表起点到某点最短路径条数的数组<pre class="line-numbers language-none"><code class="language-none">for(int v &#x3D; 0;v&lt;n;++v)&#123;&#x2F;&#x2F;如果v未被访问&amp;&amp;u能到达vif(vis[v]&#x3D;&#x3D;false&amp;&amp;G[u][v]!&#x3D;INF)&#123;&#x2F;&#x2F;INF是无穷大if(d[U]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[U]+G[u][v];num[v]&#x3D;num[u];&#125;else&#123;if(d[U]+G[u][v]&#x3D;&#x3D;d[v])&#123;num[v]+&#x3D;num[u];&#x2F;&#x2F;最短距离相同时累加num&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">Emergency</a><br><img src="/./../img/Emergency.png" alt="如图"></p><h4 id="中文释义"><a href="#中文释义" class="headerlink" title="中文释义"></a>中文释义</h4><p>作为一个城市的紧急救援队长，你会得到一张你国家的特别地图。这张地图显示了几个由一些道路连接的分散城市。地图上标出了每个城市救援队的数量以及任何两个城市之间每条道路的长度。当有来自其他城市的紧急电话打给你时，你的工作是带领你的人尽快赶到那里，同时，在路上尽可能多地召集人手。</p><p>输入格式:</p><p>每个输入文件包含一个测试用例。对于每个测试用例，第一行包含4个正整数：N(≤500）-城市数量（城市编号从0到N−1） ，M-道路数量，C 1和C 2-您当前所在的城市和您必须保存的城市。下一行包含N个整数，其中第i个整数是第i个城市中救援队的数量。接下来是M条线，每条线用三个整数c1、c2和L描述一条道路，这三个整数分别是由一条道路连接的一对城市和该道路的长度。保证从C1到C2至少存在一条路径</p><p>输出格式:</p><p>对于每个测试用例，在一行中打印两个数字：C1和C2之间不同最短路径的数量，以及您可能收集的救援团队的最大数量。一行中的所有数字必须用一个空格隔开，并且在一行的末尾不允许有额外的空格。</p><p><strong>最后，上代码</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define INF 10000#define MAXN 1010using namespace std;struct node&#123;int id;int edge_power;&#125;;typedef node PLL;vector&lt;PLL&gt; vi[MAXN];&#x2F;&#x2F;点，边，起点，终点int n,m,s,k;&#x2F;&#x2F;录起点到对应点的最短距离int d[MAXN];&#x2F;&#x2F;记录各点权int point_power[MAXN];&#x2F;&#x2F;记录起点到对应点的最大点权数目int point_power_sum[MAXN];&#x2F;&#x2F;记录各点是否访问过bool vis[MAXN]&#x3D;&#123;false&#125;;&#x2F;&#x2F;记录起点到对应点的最短路径数目int num_road[MAXN];void Dijkstra(int s)&#123;fill(d,d+MAXN,INF);fill(num_road,num_road+MAXN,0);fill(point_power_sum,point_power_sum+MAXN,0);fill(vis,vis+MAXN,false);point_power_sum[s]&#x3D;point_power[s];num_road[s]&#x3D;1;d[s]&#x3D;0;for(int i&#x3D;0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;for(int j &#x3D; 0;j&lt;n;++j)&#123;if(vis[j]&#x3D;&#x3D;false&amp;&amp;d[j]&lt;MIN)&#123;u&#x3D;j;MIN&#x3D;d[j];&#125;&#125;&#x2F;&#x2F;没找到if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].id; if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].edge_power&lt;d[v])&#123;d[v]&#x3D;d[u]+vi[u][i].edge_power;num_road[v]&#x3D;num_road[u];point_power_sum[v]&#x3D;point_power[v]+point_power_sum[u];&#125;else&#123;if(d[u]+vi[u][i].edge_power&#x3D;&#x3D;d[v])&#123;if(point_power_sum[v]&lt;point_power[v]+point_power_sum[u])&#123;point_power_sum[v]&#x3D;point_power[v]+point_power_sum[u];&#125;num_road[v]+&#x3D;num_road[u];&#125;&#125;&#125;&#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;k;&#x2F;&#x2F;cout&lt;&lt;num_road[k]&lt;&lt;&quot; &quot;&lt;&lt;point_power_sum[k];for(int i &#x3D; 0;i&lt;n;++i)&#123;&#x2F;&#x2F;输入点权cin&gt;&gt;point_power[i];&#125;for(int i &#x3D; 0;i&lt;m;++i)&#123;int x,y,edge_power;cin&gt;&gt;x&gt;&gt;y&gt;&gt;edge_power;&#x2F;&#x2F;初始化点的属性PLL pi&#123;x,edge_power&#125;;PLL pt&#123;y,edge_power&#125;;&#x2F;&#x2F;设置双向可达vi[x].push_back(pt);vi[y].push_back(pi);&#125;Dijkstra(s);cout&lt;&lt;num_road[k]&lt;&lt;&quot; &quot;&lt;&lt;point_power_sum[k];return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>你以为到这里就结束了吗，细心的读者应当注意到，上面这三种情况都是以路径上的边权或点权之 “和” 为第二标尺的，事实上也可能出现一些逻辑更为复杂的计算边权或点权的方式，此时按上面的Dijkstra算法就未必能得出正确的结果(原因是不一定满足最优子结构)，或者即使能算出，其逻辑也极其复杂，很容易写错，下面给出一种更通用、又模板化的解决此类问题的方式——Dijkstra+DFS。</strong></p><p>先思考一个问题，如果我们想要获得最优路径，应该怎么做？实际上很简单，只需要设置一个pre数组，当以v为结点可优化最短距离时，设置v的前驱结点为u即可,然后不断回溯得到当前结点的前驱结点，下面一样给出通俗易懂的递归写法</p><pre class="line-numbers language-none"><code class="language-none">if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].edge_power&lt;d[v])&#123; d[v]&#x3D;d[u]+vi[u][i].edge_power;  pre[v]&#x3D;u;&#x2F;&#x2F;设置v的前驱结点为u&#125;&#x2F;&#x2F;递归回溯void DFS(int s,int t)&#123;&#x2F;&#x2F;s是起点，t是终点if(v&#x3D;&#x3D;s)&#123;cout&lt;&lt;s;return ;&#125;DFS(s,pre[t]);cout&lt;&lt;t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事实上，可以采取先找出所有最短路径的，后找出第二标尺最优的方法，下面给出步骤</strong><br><strong>1. 设置一个vector&lt; int&gt; pre[MAXN];记录每一个结点的所有前驱结点</strong><br><strong>2. 考虑更新d[v]过程中pre数组的变化，下面直接给出代码</strong></p><pre class="line-numbers language-none"><code class="language-none">if(d[u]+G[u][v]&lt;d[v])&#123;d[v]&#x3D;d[u]+G[u][v];pre[v].clean();&#x2F;&#x2F;找到一条新路径，清除原先所有前驱结点pre[v].push_back(u);&#125;else&#123;if(d[u]+G[u][v]&#x3D;d[v])&#123;pre[v].push_back(u);&#x2F;&#x2F;找到一条相同距离的路径，直接添加即可&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以下给出模板代码，特别注意:下面的代码可以全部不修改直接默写上去(当然能理解最好)</strong></p><pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; pre[MAXN];void Dijkstra(int s)&#123;for(int i&#x3D;0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;&#x2F;&#x2F;找到最小的d[u]for(int j &#x3D; 0;j&lt;n;++j)&#123;if(vis[j]&#x3D;&#x3D;false&amp;&amp;d[j]&lt;MIN)&#123;u&#x3D;j;MIN&#x3D;d[j];&#125;&#125;&#x2F;&#x2F;没找到if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].id; if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+G[u][v]&lt;INF)&#123;d[v]&#x3D;d[u]+G[u][v];pre[v].clear();pre[v].push_back(u);&#125;else&#123;if(d[u]+vi[u][i].edge_power&#x3D;&#x3D;d[v])&#123;pre[v].push_back(u);&#125;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>已经求出所有最短路径了，那么怎么筛选出第二标尺最优的路径呢？读者应该还记得，在之前的写法中曾使用一个递归函数来寻找最短路径，此处的做法和之前相似，由于每个结点可以存在多个前驱结点，回溯的过程中就会形成一棵递归树，显然，对这棵树进行遍历时，每当到达叶子结点，就会产生一条完整的路径(想一想之前的写法是什么样的树————实际上就是一条链),因此，每得到一条完整路径，就可以对这条路径计算其第二标尺的值，如果比当前最优值更优，就更新最优值，并覆盖当前的最优路径，当所有最短路径都遍历之后，就可以得到最优第二标尺与最优最短路径。</strong></p><p><strong>首先，根据上面的分析，必须要有的是:</strong><br><strong>1. 作为全局变量的第二标尺最优值optValue</strong><br><strong>2. 记录最优路径的数组path(用vector存储)</strong><br><strong>3. 临时记录DFS遍历到叶子结点时的路径tempPath(也使用vector存储)</strong><br><strong>由此就可以给出下面的代码</strong></p><pre class="line-numbers language-none"><code class="language-none">int optvalue;&#x2F;&#x2F;记录局部第二标尺最优值vector&lt;int&gt; pre[MAXN];&#x2F;&#x2F;记录所有前驱结点vector&lt;int&gt; path,tempPath;&#x2F;&#x2F;最优路径和局部路径void DFS(int v)&#123;&#x2F;&#x2F;到达叶子结点if(v&#x3D;&#x3D;s)&#123;tempPath.push_back(v);int value;计算tempPath上的value值if(value优于optvalue)&#123;optvalue &#x3D; value;path &#x3D; tempPath;&#125;tempPath.pop_back();return ;&#125;&#x2F;&#x2F;递归式tempPath.push_back(v);for(int i &#x3D; 0;i&lt;pre[v].size();++i)&#123;DFS(pre[v][i]);&#125;tempPath.pop_back();&#x2F;&#x2F;遍历完所有前驱结点，将当前结点v清除&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读者会发现，上面的DFS代码中只有一样是要修改的(即”value优于optvalue”),这个要根据实际题目要求决定是大于还是小于，还有一点要注意，由于是递归的原因,存放在tempPath中的路径是逆序的，因此访问结点需要倒着进行才算正序.当然，如果仅是对边权或点权进行求和的话，那么正序访问也是可以的，下面给出这俩种情况的代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;边权之和int value &#x3D; 0;for(int i &#x3D; tempPath.size()-1 ; i &gt; 0 ; --i)&#123;&#x2F;&#x2F;当前结点id,下一个结点idnextint id &#x3D; tempPath[i],idnext &#x3D; tempPath[i-1];value +&#x3D; V[id][idnext];&#125;&#x2F;&#x2F;点权之和int value &#x3D; 0;for(int i &#x3D; tempPath.size()-1 ; i &gt; 0 ; --i)&#123;&#x2F;&#x2F;当前结点id,下一个结点idnextint id &#x3D; tempPath[i];value +&#x3D; w[id];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392">Travel Plan</a><br><img src="/./../img/Travel%20Plan.png" alt="如图"></p><h4 id="中文释义-1"><a href="#中文释义-1" class="headerlink" title="中文释义"></a>中文释义</h4><p>一张旅行者地图给出了公路沿线城市之间的距离，以及每条公路的成本。现在，您应该编写一个程序来帮助旅行者确定从出发城市到目的地之间的最短路径。如果这样的最短路径不是唯一的，那么您应该输出成本最小的路径，该路径保证是唯一的。</p><p>输入格式<br>每个输入文件包含一个测试用例。每种情况从一条包含4个正整数N、M、S和D的线开始，其中N(≤500）是城市的数量（因此城市的编号从0到N−1); M是公路数量；S和D分别是起点和终点城市。接下来是M行，每行以以下格式提供公路信息：<br><code>City1 City2 Distance Cost</code><br>输出格式<br>对于每个测试用例，在一行中打印从起点到目的地的最短路径上的城市，然后是路径的总距离和总成本。数字之间必须用空格隔开，并且输出端不得有额外的空格。</p><p><strong>以下给出俩种解法</strong></p><p><strong>1. Dijkstra</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define MAXN 10000#define INF 1000000000using namespace std;typedef pair&lt;int,int&gt; PLL;vector&lt;PLL&gt; vi[MAXN];int d[MAXN];int c[MAXN];int cost[MAXN][MAXN];int n,m,s,t;bool vis[MAXN]&#x3D;&#123;false&#125;;int pre[MAXN];void DFS(int v)&#123;if(v&#x3D;&#x3D;s)&#123;cout&lt;&lt;v&lt;&lt;&quot; &quot;;return ;&#125;DFS(pre[v]);cout&lt;&lt;v&lt;&lt;&quot; &quot;;&#125;void Dijkstra(int s)&#123;fill(d,d+MAXN,INF);fill(c,c+MAXN,0);d[s]&#x3D;0;for(int i &#x3D; 0;i&lt;n;++i)&#123;int u &#x3D; -1,MIN&#x3D;INF;for(int i &#x3D; 0;i&lt;n;++i)&#123;if(vis[i]&#x3D;&#x3D;false&amp;&amp;d[i]&lt;MIN)&#123;u&#x3D;i;MIN&#x3D;d[i];&#125;&#125;if(u&#x3D;&#x3D;-1)&#123;return ;&#125;vis[u]&#x3D;true;for(int i &#x3D; 0;i&lt;vi[u].size();++i)&#123;int v &#x3D; vi[u][i].first;if(vis[v]&#x3D;&#x3D;false&amp;&amp;d[u]+vi[u][i].second&lt;d[v])&#123;d[v]&#x3D;d[u]+vi[u][i].second;c[v]&#x3D;c[u]+cost[u][v];pre[v]&#x3D;u;&#125;else&#123;&#x2F;&#x2F;距离相同时if(d[u]+vi[u][i].second&#x3D;&#x3D;d[v])&#123;if(c[u]+cost[u][v]&lt;c[v])&#123;c[v]&#x3D;c[u]+cost[u][v];pre[v]&#x3D;u;&#125;&#125;&#125;&#125;&#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;for(int i &#x3D; 0;i&lt;m;++i)&#123;int id1,id2,Distance,Cost;cin&gt;&gt;id1&gt;&gt;id2&gt;&gt;Distance&gt;&gt;Cost;PLL pi&#123;id1,Distance&#125;;PLL pt&#123;id2,Distance&#125;;cost[id1][id2]&#x3D;cost[id2][id1]&#x3D;Cost;vi[id1].push_back(pt);vi[id2].push_back(pi);&#125;Dijkstra(s);DFS(t);cout&lt;&lt;d[t]&lt;&lt;&quot; &quot;&lt;&lt;c[t];return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. Dijkstra+DFS</strong></p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/19/hello-world/"/>
      <url>/2022/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到Rhss的个人博客 这是我的第一篇文章. 点击 <a href="https://hexo.io/docs/">documentation</a> 了解更多关于搭建hexo远程博客的信息. 如果途中你遇到了困难，可以点击<a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> 寻找解决办法，或者在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>寻找答案. 如果你对博客搭建也十分感兴趣的话，我建议你参考<a href="https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.337.search-card.all.click&vd_source=91a49c1d79fec015398d4ac2868b7b17">这个视频</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p><code>$ hexo new &quot;My New Post&quot;</code> </p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p><code> $ hexo server</code> </p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p><code>$ hexo generate</code>  </p><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p><code> $ hexo deploy</code>  </p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Guide </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
